import ntile

# implement bidirectional search algorithm

def bidirectional_search(initial_state):
    goal_state = ntile.ntile(initial_state.n, None)
    ans = []
    expanded_list_front = []
    expanded_list_back = []
    fringe_list_front = [{'board': initial_state, 'moves': []}]
    fringe_list_back = [{'board': goal_state, 'moves': []}]
    while fringe_list_front and fringe_list_back:
        # do bfs 1 level deeper on initial state, create a dictionary storing the ntile object, and the move played
        temp = fringe_list_front.pop(0)
        fringe_list_front += [{'board': temp['board'].newBoardMove(move),
        'moves': temp['moves'] + [move]} for move in ['U', 'D', 'L', 'R'] if (temp['board'].newBoardMove(move) is not None and temp['board'].newBoardMove(move).board not in expanded_list_front)]
        expanded_list_front.append(temp['board'])
        # do bfs 1 level deeper on goal state, create a dictionary storing the ntile object, and the move played
        temp = fringe_list_back.pop(0)
        fringe_list_back += [{'board': temp['board'].newBoardMove(move),
        'moves': temp['moves'] + [move]} for move in ['U', 'D', 'L', 'R'] if (temp['board'].newBoardMove(move) is not None) and (temp['board'].newBoardMove(move).board not in expanded_list_back)]
        expanded_list_back.append(temp['board'])
        # check if any of the ntile objects in the fringe_list_front is the same as the ntile object in the fringe_list_back efficiently using sets
        # if so, return the moves

        '''
        front_set = set(fringe_list_front[i]['board'].board_str() for i in range(len(fringe_list_front)))
        #front_set = set(front_set)
        back_set = set(fringe_list_back[i]['board'].board_str() for i in range(len(fringe_list_back)))
        #back_set = set(back_set)
        if front_set.intersection(back_set):
            ans = fringe_list_front[list(front_set.intersection(back_set))[0]]['moves']
            ans += fringe_list_back[list(front_set.intersection(back_set))[0]]['moves'].reverse()
            return ans
        '''
        for i in range(len(fringe_list_front)):
            for j in range(len(fringe_list_back)):
                if fringe_list_front[i]['board'].board == fringe_list_back[j]['board'].board:
                    if fringe_list_back[j] is not None:
                        fringe_list_back[j]['moves'].reverse()
                    # we have to invert the moves generated by the back search, ie left becomes right, right becomes left, etc.
                    for k in range(len(fringe_list_back[j]['moves'])):
                        fringe_list_back[j]['moves'][k] = {'U': 'D', 'D': 'U', 'L': 'R', 'R': 'L'}[fringe_list_back[j]['moves'][k]]
                    print("front", fringe_list_front[i]['moves'], "\nback:", fringe_list_back[j]['moves'])
                    if fringe_list_front[i] is not None:
                        if fringe_list_back[j] is not None:
                            return fringe_list_front[i]['moves'] + fringe_list_back[j]['moves']
                        else:
                            return fringe_list_front[i]['moves']
                    elif fringe_list_back[j] is not None:
                        return fringe_list_back[j]['moves']
                    else:
                        return []
        
    return None

'''
Current issue:
the search for same board algo in front and back isn't optimal
'''