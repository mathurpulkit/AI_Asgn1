import ntile

# implement bidirectional search algorithm

def bidirectional_search(initial_state):
    goal_state = ntile.ntile(initial_state.n, None)
    ans = []
    expanded_list_front = []
    expanded_list_back = []
    fringe_list_front = [{'board': initial_state, 'moves': []}]
    fringe_list_back = [{'board': goal_state, 'moves': []}]
    if initial_state.board == goal_state.board: # check if board is already solved
        return []
    
    while fringe_list_front and fringe_list_back:
        # pop top of fringe_list_front and expand it
        temp_front = fringe_list_front[0]
        fringe_list_front += [{'board': temp_front['board'].newBoardMove(move),
        'moves': temp_front['moves'] + [move]} for move in ['U', 'D', 'L', 'R'] if (temp_front['board'].newBoardMove(move) is not None and temp_front['board'].newBoardMove(move).board not in expanded_list_front)]
                
        # pop top of fringe_list_back and expand it
        temp_back = fringe_list_back[0]
        fringe_list_back += [{'board': temp_back['board'].newBoardMove(move),
        'moves': temp_back['moves'] + [move]} for move in ['U', 'D', 'L', 'R'] if (temp_back['board'].newBoardMove(move) is not None) and (temp_back['board'].newBoardMove(move).board not in expanded_list_back)]

        # check if any of the ntile objects in the fringe_list_front is the same as the ntile object in the fringe_list_back
        # if so, return the moves

        for i in range(len(fringe_list_front)):
            for j in range(len(fringe_list_back)):
                if fringe_list_front[i]['board'].board == fringe_list_back[j]['board'].board:
                    if fringe_list_back[j] is not None:
                        fringe_list_back[j]['moves'].reverse()
                    
                    # we have to invert the moves generated by the back search, ie left becomes right, right becomes left, etc.
                    for k in range(len(fringe_list_back[j]['moves'])):
                        fringe_list_back[j]['moves'][k] = {'U': 'D', 'D': 'U', 'L': 'R', 'R': 'L'}[fringe_list_back[j]['moves'][k]]
                    # print("front", fringe_list_front[i]['moves'], "\nback:", fringe_list_back[j]['moves']) # debugging statement
                    
                    if fringe_list_front[i] is not None:
                        if fringe_list_back[j] is not None:
                            return fringe_list_front[i]['moves'] + fringe_list_back[j]['moves']
                        else:
                            return fringe_list_front[i]['moves']
                    elif fringe_list_back[j] is not None:
                        return fringe_list_back[j]['moves']
                    else:
                        return []
        

        fringe_list_front.pop(0)
        fringe_list_back.pop(0)
        expanded_list_front.append(temp_front['board'])
        expanded_list_back.append(temp_back['board'])

    return None
