import ntile

# implement bidirectional search algorithm

def bidirectional_search(initial_state):
    goal_state = ntile.ntile(initial_state.n, None)
    ans = []
    fringe_list_front = [{'board': initial_state, 'moves': []}]
    fringe_list_back = [{'board': goal_state, 'moves': []}]
    while fringe_list_front and fringe_list_back:
        # do bfs 1 level deeper on initial state, create a dictionary storing the ntile object, and the move played
        fringe_list_front += [{'board': fringe_list_front[i]['board'].newBoardMove(move), 'moves': fringe_list_front[i]['moves'] + [move]} for move in ['U', 'D', 'L', 'R'] for i in range(len(fringe_list_front)) if fringe_list_front[i]['board'].newBoardMove(move) is not None]
        # do bfs 1 level deeper on goal state, create a dictionary storing the ntile object, and the move played
        fringe_list_back += [{'board': fringe_list_back[i]['board'].newBoardMove(move), 'moves': fringe_list_back[i]['moves'] + [move]} for move in ['U', 'D', 'L', 'R'] for i in range(len(fringe_list_back)) if fringe_list_back[i]['board'].newBoardMove(move) is not None]
        # check if any of the ntile objects in the fringe_list_front is the same as the ntile object in the fringe_list_back
        for i in range(len(fringe_list_front)):
            for j in range(len(fringe_list_back)):
                if fringe_list_front[i]['board'].board == fringe_list_back[j]['board'].board:
                    if fringe_list_back[j] is not None:
                        fringe_list_back[j]['moves'].reverse()
                    # we have to invert the moves generated by the back search, ie left becomes right, right becomes left, etc.
                    for k in range(len(fringe_list_front[j]['moves'])):
                        fringe_list_back[j]['moves'][k] = {'U': 'D', 'D': 'U', 'L': 'R', 'R': 'L'}[fringe_list_back[j]['moves'][k]]
                    print("front", fringe_list_front[i]['moves'], "\nback:", fringe_list_back[j]['moves'])
                    if fringe_list_front[i] is not None:
                        if fringe_list_back[j] is not None:
                            return fringe_list_front[i]['moves'] + fringe_list_back[j]['moves']
                        else:
                            return fringe_list_front[i]['moves']
                    elif fringe_list_back[j] is not None:
                        return fringe_list_back[j]['moves']
                    else:
                        return []

    return None

'''
Current bug issue:
the last move to be played(that is, the first move played by back search) is generated not inverted
that is, up is not generated as down, rather up only
this causes the answer printed to be incorrect
as we generate the answer by inverting the moves of the back list, then reversing it(which works fine AFAIK)
'''